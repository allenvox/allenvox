# Программирование

### 1. **Понятия алгоритм, программа, программирование. Процесс получения исполняемой программы из исходных кодов**

**Алгоритм:** это конечная последовательность четко определенных действий, предназначенных для решения задачи или выполнения задачи. Алгоритмы должны быть корректными, детерминированными и эффективными.

**Программа:** это набор инструкций на определенном языке программирования, который реализует алгоритм и может быть выполнен компьютером.

**Программирование:** это процесс создания программ, включающий разработку алгоритмов, написание кода, его тестирование и отладку.

**Процесс получения исполняемой программы из исходных кодов:**  
1. **Написание исходного кода:** код программы пишется на языке программирования (например, C, Java, Python).  
2. **Компиляция:** компилятор преобразует исходный код в машинный код.  
3. **Линковка:** связывание с внешними библиотеками и создание исполняемого файла.  
4. **Загрузка и выполнение:** операционная система загружает программу и передает управление процессору для выполнения.

---

### 2. **Представление информации в ЭВМ. Системы счисления. Связь между системами счисления**

**Представление информации в ЭВМ:**  
В компьютерах информация представлена в виде последовательности двоичных битов (0 и 1). Эти биты образуют байты, из которых формируются более сложные структуры данных, такие как числа, текст и мультимедиа.

**Системы счисления:**  
1. **Двоичная (база 2):** используется в компьютерах. Цифры — 0, 1.  
2. **Восьмеричная (база 8):** часто используется для удобного представления больших двоичных чисел. Цифры — от 0 до 7.  
3. **Десятичная (база 10):** привычная для человека. Цифры — от 0 до 9.  
4. **Шестнадцатеричная (база 16):** удобна для представления памяти. Цифры — от 0 до 9 и A-F.

**Связь между системами счисления:**  
- Перевод из десятичной в двоичную выполняется последовательным делением на 2.  
- Перевод из двоичной в восьмеричную и шестнадцатеричную выполняется группировкой битов (3 бита — восьмеричная, 4 бита — шестнадцатеричная).  
- Перевод из любой системы в десятичную осуществляется суммированием произведений цифр на основание системы в соответствующей степени.

---

### 3. **Типы данных. Внутреннее представление базовых типов данных. Преобразование типов данных**

**Типы данных:**  
Типы данных определяют формат хранения и допустимые операции. Базовые типы:
- **Целые числа (int)** — 4 байта, представляются в дополнительном коде.
- **Вещественные числа (float, double)** — 4 и 8 байт, представляются по стандарту IEEE 754.
- **Символы (char)** — 1 байт, внутреннее представление — кодировка ASCII или Unicode.
- **Логические (bool)** — 1 байт, значение true или false.

**Внутреннее представление:**  
- **Целые числа:** представляются двоичным кодом с учетом знака.  
- **Вещественные числа:** содержат знак, мантиссу и порядок.  
- **Символы:** кодируются числовыми значениями ASCII или Unicode.

**Преобразование типов:**  
- **Неявное преобразование:** происходит автоматически, например, при сложении int и float.  
- **Явное преобразование:** осуществляется с помощью приведения (casting), например `(int)3.14`.  

---

### 4. **Указатели в языке Си. Тип указателя. Действия над указателями**

**Указатели:** это переменные, которые хранят адрес другой переменной.

**Тип указателя:** зависит от типа данных, на которые он указывает. Например:
```c
int *p; // указатель на целое число
char *c; // указатель на символ
```

**Действия над указателями:**  
1. **Присваивание адреса:** `int x = 10; int *p = &x;`  
2. **Разыменование:** доступ к значению по адресу `*p = 20;`  
3. **Арифметика указателей:** `p++` переходит к следующему элементу типа `int`.  
4. **Передача указателей в функции:** позволяет эффективно работать с большими данными.  

---

### 5. **Алгоритмы на базе циклических конструкций. Элементарная теория чисел**

**Алгоритмы на базе циклов:**  
Циклы позволяют многократно выполнять блок инструкций. Основные типы циклов:
- `for` — используется, когда известно количество итераций.
- `while` — выполняется, пока истинно условие.
- `do...while` — выполняется хотя бы один раз.

**Примеры:**  
- Нахождение суммы чисел от 1 до N.
- Поиск делителей числа.

**Элементарная теория чисел:**  
Раздел математики, изучающий свойства целых чисел:
- **Простые числа:** делятся только на 1 и на себя.
- **НОД:** наибольший общий делитель (алгоритм Евклида).
- **НОК:** наименьшее общее кратное.

---

### 6. **Понятие массива в языках программирования, области его применения**

**Массив:** это структура данных, которая хранит набор элементов одного типа, расположенных последовательно в памяти.

**Области применения:**  
- Хранение коллекций однотипных данных.
- Реализация алгоритмов сортировки и поиска.
- Построение сложных структур данных (стек, очередь, матрица).

**Пример объявления массива:**  
```c
int arr[5] = {1, 2, 3, 4, 5};
```

---

### 7. **Алгоритмы обработки массивов. Задача поиска простых чисел. Линейный алгоритм. Алгоритм Эратосфена**

**Алгоритмы обработки массивов:**  
- **Поиск:** линейный поиск, бинарный поиск.  
- **Сортировка:** пузырьковая, быстрая сортировка.  
- **Анализ:** нахождение максимума, минимума.

**Задача поиска простых чисел:**  
Число простое, если оно делится только на 1 и само себя.

**Линейный алгоритм:**  
Перебор всех чисел от 2 до n и проверка на делимость.

**Алгоритм Эратосфена:**  
1. Создать массив булевых значений от 2 до n.  
2. Пометить все числа как простые.  
3. Удалять кратные каждого простого числа.  

Пример реализации на C:
```c
#include <stdio.h>
#include <stdbool.h>

void sieveOfEratosthenes(int n) {
    bool primes[n + 1];
    for (int i = 0; i <= n; i++)
        primes[i] = true;

    for (int p = 2; p * p <= n; p++) {
        if (primes[p]) {
            for (int i = p * p; i <= n; i += p)
                primes[i] = false;
        }
    }

    for (int p = 2; p <= n; p++) {
        if (primes[p])
            printf("%d ", p);
    }
}

int main() {
    int n = 50;
    printf("Простые числа до %d:\n", n);
    sieveOfEratosthenes(n);
    return 0;
}
```

---

### **8. Понятие сортировки. Алгоритмы сортировки. Оценка алгоритмов сортировки**

**Сортировка:** это процесс упорядочивания элементов массива или списка в определенном порядке (по возрастанию или убыванию).

**Алгоритмы сортировки:**  
1. **Пузырьковая сортировка (Bubble Sort):**  
   Повторяющееся сравнение соседних элементов и их обмен, если они расположены в неправильном порядке.  
   - Время выполнения: \(O(n^2)\)  
   - Простой, но неэффективный алгоритм.

2. **Сортировка выбором (Selection Sort):**  
   На каждом шаге ищется минимальный элемент и помещается на соответствующую позицию.  
   - Время выполнения: \(O(n^2)\)

3. **Сортировка вставками (Insertion Sort):**  
   Каждый новый элемент вставляется в отсортированную часть массива.  
   - Время выполнения: \(O(n^2)\) в худшем случае.

4. **Быстрая сортировка (Quick Sort):**  
   Выбирается опорный элемент, а остальные элементы разделяются на две группы (меньшие и большие).  
   - Время выполнения: \(O(n \log n)\) в среднем случае.

5. **Сортировка слиянием (Merge Sort):**  
   Массив рекурсивно делится на части и объединяется в отсортированном порядке.  
   - Время выполнения: \(O(n \log n)\).

**Оценка алгоритмов сортировки:**  
- Оцениваются по временной сложности (\(O(n)\), \(O(n^2)\)) и по сложности памяти (\(O(1)\) или \(O(n)\)).

---

### **9. Представление строк в языке Си. Представление символов**

**Строки в языке Си:**  
Строка — это массив символов, который завершается специальным символом `\0` (нулевой байт).

**Пример строки:**  
```c
char str[] = "Hello, World!";
```

**Представление символов:**  
Символы представляются целыми числами в соответствии с таблицей ASCII или Unicode.

**Пример работы с символами:**  
```c
char c = 'A';
printf("Код символа: %d\n", c);  // Выведет 65
```

---

### **10. Операции над строками. Операции над строками в многобайтовой кодировке**

**Операции над строками в Си:**  
Для работы со строками используются функции из библиотеки `<string.h>`:  
1. **Копирование строки:** `strcpy(dest, src);`  
2. **Конкатенация:** `strcat(dest, src);`  
3. **Сравнение:** `strcmp(str1, str2);`  
4. **Определение длины:** `strlen(str);`  
5. **Поиск подстроки:** `strstr(str1, str2);`

**Операции над строками в многобайтовой кодировке:**  
В многобайтовых кодировках, таких как UTF-8, стандартные функции могут не работать корректно. Для работы используются функции из `<wchar.h>`:
- `wcscpy`, `wcscat`, `wcslen`, `wcscmp`. 

---

### **11. Понятие функции в языке Си. Определение, объявление и вызов функции. Указатель на функцию**

**Функция:** это блок кода, который выполняет определенную задачу и может быть вызван из других частей программы.

**Определение и объявление функции:**  
- **Объявление (прототип):**  
  ```c
  int sum(int a, int b);
  ```
- **Определение:**  
  ```c
  int sum(int a, int b) {
      return a + b;
  }
  ```

**Вызов функции:**  
```c
int result = sum(3, 5);
```

**Указатели на функции:**  
Указатели на функции позволяют передавать функции как параметры другим функциям:
```c
#include <stdio.h>

int sum(int a, int b) {
    return a + b;
}

int main() {
    int (*func_ptr)(int, int) = sum;
    printf("Результат: %d\n", func_ptr(2, 3));
    return 0;
}
```

---

### **12. Функции с параметрами переменной длины. Передача параметров функции main**

**Функции с параметрами переменной длины:**  
Используются для обработки неопределенного количества аргументов. Пример — функция `printf`.

**Пример реализации:**  
```c
#include <stdio.h>
#include <stdarg.h>

int sum(int count, ...) {
    va_list args;
    va_start(args, count);

    int total = 0;
    for (int i = 0; i < count; i++) {
        total += va_arg(args, int);
    }

    va_end(args);
    return total;
}

int main() {
    printf("Сумма: %d\n", sum(3, 1, 2, 3));
    return 0;
}
```

**Передача параметров функции `main`:**  
Функция `main` может принимать аргументы командной строки:
```c
int main(int argc, char *argv[]) {
    for (int i = 0; i < argc; i++) {
        printf("Аргумент %d: %s\n", i, argv[i]);
    }
    return 0;
}
```

---

### **13. Многофайловые программы. Классы памяти переменных**

**Многофайловые программы:**  
Крупные программы делятся на несколько файлов для удобства разработки и сопровождения.  
- **Файлы заголовков (.h):** содержат объявления функций и глобальных переменных.
- **Файлы реализации (.c):** содержат определения функций и логики программы.
  
**Пример структуры:**  
- `main.c`
- `utils.h`
- `utils.c`

Компиляция выполняется командой:
```sh
gcc main.c utils.c -o program
```

**Классы памяти переменных:**  
1. **Автоматические (auto):** по умолчанию для локальных переменных, размещаются в стеке.  
2. **Статические (static):** сохраняют значение между вызовами функций.  
3. **Регистровые (register):** хранятся в регистрах процессора (рекомендация для оптимизации).  
4. **Внешние (extern):** видимы во всех файлах программы.

Пример использования `static`:  
```c
#include <stdio.h>

void counter() {
    static int count = 0;
    count++;
    printf("Count: %d\n", count);
}

int main() {
    counter();
    counter();
    counter();
    return 0;
}
```

---  

### **14. Структурный тип данных. Тип данных объединение**

**Структурный тип данных:**  
Структура (struct) — это пользовательский тип данных, который объединяет набор переменных разного типа под одним именем.

**Пример структуры:**  
```c
#include <stdio.h>

struct Student {
    char name[50];
    int age;
    float grade;
};

int main() {
    struct Student student1 = {"Alice", 20, 4.5};
    printf("Имя: %s, Возраст: %d, Оценка: %.1f\n", student1.name, student1.age, student1.grade);
    return 0;
}
```

**Тип данных объединение (union):**  
Объединение (union) — это структура, где все переменные используют одно и то же место в памяти. Размер объединения равен размеру его самого большого поля.

**Пример объединения:**  
```c
#include <stdio.h>

union Data {
    int i;
    float f;
    char str[20];
};

int main() {
    union Data data;
    data.i = 10;
    printf("int: %d\n", data.i);

    data.f = 3.14;
    printf("float: %.2f\n", data.f);

    strcpy(data.str, "Hello");
    printf("string: %s\n", data.str);

    return 0;
}
```

⚠️ Важно: При использовании объединений нужно помнить, что изменение одного поля затрагивает все остальные.

---

### **15. Понятие файла. Файловая система. Операции с файлом**

**Понятие файла:**  
Файл — это именованная область на носителе информации, предназначенная для хранения данных.

**Файловая система:**  
Организует хранение и доступ к файлам на носителе. Состоит из каталогов, файлов и метаданных. Примеры файловых систем: NTFS, FAT32, ext4.

**Операции с файлами:**  
1. **Открытие файла:** установка связи между программой и файлом.  
2. **Чтение и запись:** операции ввода-вывода.  
3. **Закрытие файла:** освобождение ресурсов.  
4. **Удаление и переименование:** операции управления файлами.

---

### **16. Работа с файлами в языке Си**

**Основные функции работы с файлами:**  
Для работы с файлами используется библиотека `<stdio.h>`.

1. **Открытие файла:**  
```c
FILE *fopen(const char *filename, const char *mode);
```
Режимы открытия:
- `r` — чтение
- `w` — запись (удаляет существующий файл)
- `a` — добавление
- `rb`, `wb`, `ab` — для бинарных файлов

2. **Чтение и запись:**  
```c
fscanf(), fprintf(), fread(), fwrite(), fgetc(), fputc()
```

3. **Закрытие файла:**  
```c
fclose(file);
```

**Пример работы с файлом:**  
```c
#include <stdio.h>

int main() {
    FILE *file = fopen("example.txt", "w");
    if (file == NULL) {
        printf("Ошибка открытия файла\n");
        return 1;
    }

    fprintf(file, "Привет, мир!\n");
    fclose(file);

    file = fopen("example.txt", "r");
    char buffer[100];
    fgets(buffer, 100, file);
    printf("Содержимое файла: %s", buffer);

    fclose(file);
    return 0;
}
```

---

### **17. Отладка компьютерных программ. Опции компилятора. Понятие трассировки. Управление точками останова. Команды отладчика**

**Отладка компьютерных программ:**  
Это процесс выявления и исправления ошибок в коде программы. Включает в себя анализ логики программы, контроль значений переменных и выявление причин сбоев.

**Опции компилятора:**  
При компиляции можно использовать опции для отладки. Например, в компиляторе GCC:
- `-g`: включение информации для отладки.
- `-Wall`: предупреждения о возможных ошибках.
- `-O0`: отключение оптимизаций для удобства отладки.

**Понятие трассировки:**  
Это процесс отслеживания выполнения программы с выводом информации о каждом этапе работы, включая значения переменных и выполняемые команды.

**Точки останова:**  
Точка останова (breakpoint) позволяет остановить выполнение программы в определенном месте для анализа состояния программы.

**Команды отладчика:**  
Для отладки используется GDB (GNU Debugger):
- `gdb ./program`: запуск программы под отладчиком.
- `break main`: установка точки останова в функции `main`.
- `run`: запуск программы.
- `next`: выполнение следующей строки.
- `print var`: вывод значения переменной.
- `continue`: продолжение выполнения программы.
- `quit`: выход из отладчика.

**Пример использования GDB:**  
```bash
gcc -g program.c -o program
gdb program
```
