# Структуры и алгоритмы обработки данных
### **1. Понятие алгоритма. Свойства алгоритмов. Показатели эффективности алгоритмов. Анализ времени выполнения алгоритмов**

**Понятие алгоритма:**  
Алгоритм — это конечная последовательность действий, направленных на решение поставленной задачи за конечное время.

**Свойства алгоритмов:**  
1. **Дискретность:** алгоритм состоит из отдельных шагов.  
2. **Определенность:** каждое действие должно быть четко определено.  
3. **Конечность:** выполнение алгоритма должно завершаться за конечное время.  
4. **Результативность:** алгоритм должен давать правильный результат или сообщать об ошибке.  
5. **Массовость:** алгоритм должен быть применим к широкому кругу задач одного типа.

**Показатели эффективности алгоритмов:**  
1. **Временная сложность:** количество элементарных операций, выполняемых алгоритмом.  
2. **Пространственная сложность:** объем используемой памяти.  

**Анализ времени выполнения алгоритмов:**  
Определяется числом операций в зависимости от размера входных данных. Например, для сортировки массива из \(n\) элементов:
- В лучшем случае: \(O(n)\)
- В среднем случае: \(O(n \log n)\)
- В худшем случае: \(O(n^2)\)

---

### **2. Асимптотический анализ вычислительной сложности алгоритмов. Анализ вычислительной сложности в худшем, среднем и лучшем случаях. Асимптотические обозначения O, Θ, Ω. Основные классы сложности алгоритмов**

**Асимптотический анализ:**  
Позволяет оценить эффективность алгоритмов для больших объемов данных, игнорируя незначительные константы и множители.

**Анализ сложности:**  
1. **В худшем случае (worst-case):** максимальное количество операций.  
2. **В среднем случае (average-case):** среднее количество операций для произвольных входных данных.  
3. **В лучшем случае (best-case):** минимальное количество операций.  

**Асимптотические обозначения:**  
1. **\(O(f(n))\)** — верхняя граница сложности. Алгоритм выполняется за не более чем \(f(n)\) операций.  
2. **\(\Theta(f(n))\)** — точная асимптотика. Алгоритм выполняется ровно за \(f(n)\) операций.  
3. **\(\Omega(f(n))\)** — нижняя граница сложности. Алгоритм выполняется как минимум за \(f(n)\) операций.

**Основные классы сложности:**  
- \(O(1)\) — константное время  
- \(O(\log n)\) — логарифмическое время  
- \(O(n)\) — линейное время  
- \(O(n \log n)\) — квазилинейное время  
- \(O(n^2)\) — квадратичное время  
- \(O(2^n)\) — экспоненциальное время  

Пример: бинарный поиск имеет сложность \(O(\log n)\), а сортировка выбором — \(O(n^2)\).

---

### **3. Анализ рекурсивных алгоритмов. Стек вызовов функций. Виды рекурсии. Решение рекуррентных уравнений. Основная теорема (master method). Анализ эффективности алгоритма сортировки слиянием**

**Рекурсивные алгоритмы:**  
Алгоритмы, которые вызывают сами себя для решения подзадачи.

**Стек вызовов функций:**  
При каждом рекурсивном вызове в стек помещаются параметры функции и адрес возврата. После завершения вызова функция удаляется из стека.

**Виды рекурсии:**  
1. **Прямая рекурсия:** функция вызывает сама себя напрямую.  
   ```c
   int factorial(int n) {
       if (n == 0) return 1;
       return n * factorial(n - 1);
   }
   ```
2. **Косвенная рекурсия:** функция вызывает другую функцию, которая в свою очередь вызывает исходную.  
   ```c
   void A() {
       B();
   }

   void B() {
       A();
   }
   ```

**Рекуррентные уравнения:**  
Определяют сложность рекурсивных алгоритмов. Например, для сортировки слиянием рекуррентное уравнение:  
\[
T(n) = 2T\left(\frac{n}{2}\right) + O(n)
\]

**Основная теорема (Master theorem):**  
Используется для решения рекуррентных уравнений вида:
\[
T(n) = a \cdot T\left(\frac{n}{b}\right) + O(n^c)
\]
Где:
- \(a\) — количество подзадач
- \(b\) — во сколько раз уменьшается размер задачи
- \(c\) — сложность разделения задачи

Три случая:
1. Если \(c < \log_b(a)\), то \(T(n) = O(n^{\log_b(a)})\)  
2. Если \(c = \log_b(a)\), то \(T(n) = O(n^c \log n)\)  
3. Если \(c > \log_b(a)\), то \(T(n) = O(n^c)\)

**Пример:** Сортировка слиянием \(T(n) = 2T(n/2) + O(n)\) соответствует второму случаю:
\[
T(n) = O(n \log n)
\]

**Анализ эффективности алгоритма сортировки слиянием:**  
- Время выполнения: \(O(n \log n)\)  
- Пространственная сложность: \(O(n)\)

---

### **4. Задача сортировки. Виды алгоритмов сортировки: устойчивые алгоритмы, сортировки сравнением, сортировки на месте (in-place). Сортировка вставками. Сортировка слиянием. Быстрая сортировка. Пирамидальная сортировка. Поразрядная сортировка**

**Задача сортировки:**  
Необходимо переставить элементы массива в определенном порядке (обычно по возрастанию или убыванию).

#### **Классификация алгоритмов сортировки**

1. **Устойчивые алгоритмы:** сохраняют порядок равных элементов.
   - Примеры: сортировка слиянием, сортировка вставками.

2. **Неустойчивые алгоритмы:** порядок равных элементов может измениться.
   - Примеры: быстрая сортировка, пирамидальная сортировка.

3. **Сортировки сравнением:** работают путем последовательного сравнения элементов.
   - Примеры: сортировка вставками, быстрая сортировка.

4. **Сортировки без сравнений:** используют свойства данных (например, разряды чисел).
   - Пример: поразрядная сортировка.

5. **In-place сортировки:** требуют \(O(1)\) дополнительной памяти.
   - Примеры: быстрая сортировка, сортировка вставками.

#### **Основные алгоритмы сортировки**

1. **Сортировка вставками (Insertion Sort)**  
Простой алгоритм, эффективен для небольших массивов или частично отсортированных данных.  
**Сложность:** \(O(n^2)\) в худшем случае.

**Пример кода:**
```c
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

2. **Сортировка слиянием (Merge Sort)**  
Разделяет массив на части и объединяет их в отсортированном порядке.  
**Сложность:** \(O(n \log n)\)

**Пример кода:**
```c
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    int L[n1], R[n2];

    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int i = 0; i < n2; i++) R[i] = arr[mid + 1 + i];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) arr[k++] = L[i++];
        else arr[k++] = R[j++];
    }

    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}
```

3. **Быстрая сортировка (Quick Sort)**  
Выбирает опорный элемент (pivot) и делит массив на части.  
**Сложность:** \(O(n \log n)\) в среднем случае.

**Пример кода:**
```c
int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return i + 1;
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

4. **Пирамидальная сортировка (Heap Sort)**  
Использует структуру данных "куча".  
**Сложность:** \(O(n \log n)\)

5. **Поразрядная сортировка (Radix Sort)**  
Основана на сортировке чисел по разрядам.  
**Сложность:** \(O(nk)\), где \(k\) — количество разрядов числа.

---

### **5. Поиск элемента по ключу. Линейный поиск. Бинарный поиск. Экспоненциальный поиск (Galloping Search)**

#### **Линейный поиск (Linear Search)**  
Перебирает элементы массива последовательно.

**Сложность:** \(O(n)\)  
**Пример кода:**
```c
int linearSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) return i;
    }
    return -1;
}
```

#### **Бинарный поиск (Binary Search)**  
Работает только для отсортированных массивов. Делит массив на две части и ищет в соответствующем подмассиве.

**Сложность:** \(O(\log n)\)  
**Пример кода:**
```c
int binarySearch(int arr[], int n, int key) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == key) return mid;
        if (arr[mid] < key) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

#### **Экспоненциальный поиск (Galloping Search)**  
Эффективен для поиска в отсортированных структурах. Сначала ищет границы диапазона экспоненциальным шагом, затем выполняет бинарный поиск.

**Сложность:** \(O(\log n)\)  
**Пример работы:**  
1. Шаг увеличивается как \(2^i\) (\(1, 2, 4, 8, \dots\)).
2. После нахождения диапазона выполняется бинарный поиск.

---

### **6. Абстрактный тип данных «список». Связный список. Односвязный список, двусвязный список. Основные операции и их вычислительная сложность**

**Абстрактный тип данных (АТД) «список»:**  
Структура данных, которая представляет упорядоченную последовательность элементов. Элементы могут быть добавлены, удалены или извлечены.

#### **Связный список:**  
Каждый элемент (узел) хранит данные и указатель на следующий элемент.

##### **Односвязный список:**  
- Узел содержит два поля: значение и указатель на следующий узел.

**Основные операции и их сложность:**  
- Вставка в начало: \(O(1)\)  
- Вставка в конец: \(O(n)\)  
- Удаление элемента: \(O(n)\)  
- Поиск элемента: \(O(n)\)

**Пример узла односвязного списка на языке Си:**  
```c
typedef struct Node {
    int data;
    struct Node* next;
} Node;
```

##### **Двусвязный список:**  
- Узел содержит три поля: значение, указатель на предыдущий и следующий узлы.

**Основные операции и их сложность:**  
- Вставка в начало или конец: \(O(1)\)  
- Удаление элемента: \(O(1)\) при известном указателе  
- Поиск элемента: \(O(n)\)

**Пример узла двусвязного списка:**  
```c
typedef struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
} Node;
```

---

### **7. Стек. Способы реализации стека. Основные операции и их вычислительная сложность**

**Стек:**  
АТД, работающий по принципу «последним пришел — первым ушел» (LIFO).  

#### **Основные операции:**  
- **push(x)** — добавление элемента на вершину стека (\(O(1)\))  
- **pop()** — удаление элемента с вершины стека (\(O(1)\))  
- **peek()** — просмотр элемента на вершине стека (\(O(1)\))  

#### **Способы реализации:**  

1. **На массиве:**  
Легко реализуем, но требует контроля за размером массива.

**Пример реализации стека на массиве:**  
```c
#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;

void push(Stack* s, int value) {
    if (s->top < MAX_SIZE - 1) {
        s->data[++s->top] = value;
    }
}

int pop(Stack* s) {
    if (s->top >= 0) {
        return s->data[s->top--];
    }
    return -1;  // Пустой стек
}
```

2. **На связном списке:**  
Не ограничен фиксированным размером.

**Пример реализации стека на списке:**  
```c
typedef struct Node {
    int data;
    struct Node* next;
} Node;

Node* push(Node* top, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = top;
    return newNode;
}

Node* pop(Node* top) {
    if (top == NULL) return NULL;
    Node* temp = top;
    top = top->next;
    free(temp);
    return top;
}
```

---

### **8. Очередь. Способы реализации очереди. Основные операции и их вычислительная сложность. Реализация очереди на основе циклического массива. Двухсторонняя очередь (дек, deque)**

**Очередь:**  
АТД, работающий по принципу «первым пришел — первым ушел» (FIFO).

#### **Основные операции:**  
- **enqueue(x)** — добавление элемента в конец очереди (\(O(1)\))  
- **dequeue()** — удаление элемента из начала очереди (\(O(1)\))  
- **peek()** — просмотр элемента в начале (\(O(1)\))  

#### **Способы реализации:**  

1. **На массиве:**  
Имеет фиксированный размер.

2. **На циклическом массиве:**  
Проблема переполнения решается за счет циклического доступа.

**Пример реализации очереди на циклическом массиве:**  
```c
#define MAX_SIZE 5

typedef struct {
    int data[MAX_SIZE];
    int front;
    int rear;
    int size;
} CircularQueue;

void enqueue(CircularQueue* q, int value) {
    if (q->size == MAX_SIZE) return; // Переполнение
    q->rear = (q->rear + 1) % MAX_SIZE;
    q->data[q->rear] = value;
    q->size++;
}

int dequeue(CircularQueue* q) {
    if (q->size == 0) return -1; // Пустая очередь
    int value = q->data[q->front];
    q->front = (q->front + 1) % MAX_SIZE;
    q->size--;
    return value;
}
```

#### **Двухсторонняя очередь (Deque)**  
Очередь, где добавление и удаление возможно с обоих концов.

**Основные операции:**  
- **push_front(x)** — добавление в начало (\(O(1)\))  
- **push_back(x)** — добавление в конец (\(O(1)\))  
- **pop_front()** — удаление из начала (\(O(1)\))  
- **pop_back()** — удаление из конца (\(O(1)\))  

Deque реализуется как на массиве, так и на двусвязном списке.

---

### **9. Абстрактный тип данных «словарь». Основные операции словаря. Бинарные деревья поиска. Основные операции, их вычислительная сложность. Анализ эффективности бинарного дерева поиска в среднем и худшем случае**

#### **АТД «словарь» (Dictionary):**
Это структура данных, которая хранит пары «ключ — значение» и поддерживает эффективный поиск, добавление и удаление элементов по ключу.

#### **Основные операции словаря:**
- **insert(key, value)** — добавление новой пары ключ-значение (\(O(\log n)\) для бинарного дерева).
- **delete(key)** — удаление элемента по ключу (\(O(\log n)\) для бинарного дерева).
- **search(key)** — поиск элемента по ключу (\(O(\log n)\) для бинарного дерева).

#### **Бинарные деревья поиска (Binary Search Trees, BST)**  

Бинарное дерево поиска — структура данных, где каждый узел имеет не более двух дочерних узлов:  
- Левый поддерево содержит значения меньше текущего узла.  
- Правое поддерево содержит значения больше текущего узла.

#### **Основные операции и их сложность:**  
1. **Поиск элемента (Search):**  
   Спускаемся вниз по дереву в зависимости от значения ключа.  
   **Сложность:** \(O(h)\), где \(h\) — высота дерева.

2. **Добавление элемента (Insert):**  
   Похож на поиск, добавляем новый узел на найденную позицию.  
   **Сложность:** \(O(h)\)

3. **Удаление элемента (Delete):**  
   Сложнее операции вставки, возможны три случая:  
   - Узел — лист (без детей).
   - Узел имеет одного ребенка.
   - Узел имеет двух детей. В этом случае заменяем его минимальным элементом из правого поддерева.  
   **Сложность:** \(O(h)\)

#### **Анализ эффективности BST:**  
- **Средний случай:** высота дерева пропорциональна \(\log n\), сложность операций \(O(\log n)\).  
- **Худший случай:** если дерево вырождено в список, то сложность операций \(O(n)\).

**Пример реализации бинарного дерева поиска на языке Си:**  
```c
typedef struct Node {
    int key;
    struct Node *left, *right;
} Node;

Node* newNode(int key) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->key = key;
    node->left = node->right = NULL;
    return node;
}

Node* insert(Node* root, int key) {
    if (root == NULL) return newNode(key);

    if (key < root->key) root->left = insert(root->left, key);
    else if (key > root->key) root->right = insert(root->right, key);

    return root;
}

Node* search(Node* root, int key) {
    if (root == NULL || root->key == key) return root;
    if (key < root->key) return search(root->left, key);
    return search(root->right, key);
}
```

---

### **10. Абстрактный тип данных «словарь». Хеш-таблицы. Основные операции хеш-таблицы. Хеш-функции. Методы разрешения коллизий**

#### **Хеш-таблицы:**  
Структура данных для хранения пар ключ-значение с использованием хеш-функции.

#### **Основные операции и их сложность:**  
1. **insert(key, value)** — добавление элемента (\(O(1)\) в среднем случае)  
2. **delete(key)** — удаление элемента (\(O(1)\))  
3. **search(key)** — поиск элемента по ключу (\(O(1)\))  

#### **Хеш-функции:**  
Функции, которые преобразуют ключ в индекс массива. Хорошая хеш-функция должна быть быстрой и равномерно распределять ключи по таблице.

**Примеры простых хеш-функций:**  
1. Остаток от деления:
   \[
   hash(key) = key \mod size
   \]
2. Функции для строк, например, алгоритм «полиномиальный хеш».

#### **Методы разрешения коллизий:**  

1. **Открытая адресация:**  
   При коллизии ищется следующая свободная ячейка.
   - Линейное пробирование: \(hash(key, i) = (hash(key) + i) \mod size\)  
   - Квадратичное пробирование: \(hash(key, i) = (hash(key) + i^2) \mod size\)  
   - Двойное хеширование.

2. **Метод цепочек:**  
   В каждой ячейке таблицы хранится связный список элементов с одинаковым хеш-значением.

**Пример реализации хеш-таблицы с методом цепочек:**  
```c
#define TABLE_SIZE 10

typedef struct Node {
    int key;
    int value;
    struct Node* next;
} Node;

Node* hashTable[TABLE_SIZE];

int hash(int key) {
    return key % TABLE_SIZE;
}

void insert(int key, int value) {
    int index = hash(key);
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->key = key;
    newNode->value = value;
    newNode->next = hashTable[index];
    hashTable[index] = newNode;
}

int search(int key) {
    int index = hash(key);
    Node* node = hashTable[index];
    while (node != NULL) {
        if (node->key == key) return node->value;
        node = node->next;
    }
    return -1; // Элемент не найден
}
```

---

### **11. Очереди с приоритетом. Бинарные кучи. Реализация бинарной кучи на основе массива. Построение бинарной кучи за время \(O(n)\)**

#### **Очередь с приоритетом:**  
Структура данных, где каждый элемент имеет приоритет, и элементы с более высоким приоритетом извлекаются первыми.

**Основные операции очереди с приоритетом:**  
- **insert(x)** — добавление элемента (\(O(\log n)\))  
- **extract_max() / extract_min()** — извлечение элемента с максимальным/минимальным приоритетом (\(O(\log n)\))  
- **peek()** — просмотр элемента с максимальным/минимальным приоритетом (\(O(1)\))

#### **Бинарные кучи:**  
Полное бинарное дерево, где каждый узел подчиняется свойству кучи:  
- Для **max-heap:** ключ родителя всегда больше или равен ключам потомков.  
- Для **min-heap:** ключ родителя меньше или равен ключам потомков.

##### **Реализация на основе массива:**  
- Для узла с индексом \(i\):  
  - Левый потомок: \(2i + 1\)  
  - Правый потомок: \(2i + 2\)  
  - Родитель: \(\lfloor (i - 1) / 2 \rfloor\)

**Пример структуры кучи:**  
```c
typedef struct {
    int data[100];
    int size;
} BinaryHeap;
```

#### **Построение бинарной кучи за время \(O(n)\)**  
Используется метод «просеивания вниз» (heapify).

**Пример построения бинарной кучи:**  
```c
void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest])
        largest = left;

    if (right < n && arr[right] > arr[largest])
        largest = right;

    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
        heapify(arr, n, largest);
    }
}

void buildHeap(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
}
```
---

### **12. Графы. Виды графов. Способы представления графов в памяти. Реализация графа на основе матрицы смежности**

#### **Виды графов:**  
- **Направленные и ненаправленные:** рёбра имеют направление или нет.  
- **Взвешенные и невзвешенные:** рёбра имеют вес или нет.  
- **Связные и несвязные:** из любой вершины достижимы все другие или нет.

#### **Способы представления графов:**  

1. **Матрица смежности:**  
   Двумерный массив, где элемент \([i][j]\) хранит 1, если есть ребро между вершинами \(i\) и \(j\), и 0 иначе.

**Пример реализации на языке Си:**  
```c
#define MAX_VERTICES 5

int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES] = {0};

void addEdge(int u, int v) {
    adjacencyMatrix[u][v] = 1;
    adjacencyMatrix[v][u] = 1; // для неориентированного графа
}
```

2. **Список смежности:**  
   Массив списков, где каждый элемент массива содержит список смежных вершин.

---

### **13. Обход графа. Обход в глубину (DFS). Обход в ширину (BFS)**

#### **Обход в глубину (DFS)**  
Алгоритм, который рекурсивно исследует вершины, углубляясь максимально далеко.  

**Пример реализации на языке Си:**  
```c
#include <stdio.h>

#define MAX_VERTICES 5

int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES] = {
    {0, 1, 0, 0, 1},
    {1, 0, 1, 0, 1},
    {0, 1, 0, 1, 0},
    {0, 0, 1, 0, 1},
    {1, 1, 0, 1, 0}
};

int visited[MAX_VERTICES] = {0};

void dfs(int vertex) {
    printf("Visited %d\n", vertex);
    visited[vertex] = 1;

    for (int i = 0; i < MAX_VERTICES; i++) {
        if (adjacencyMatrix[vertex][i] == 1 && !visited[i]) {
            dfs(i);
        }
    }
}
```

#### **Обход в ширину (BFS)**  
Алгоритм, который исследует все вершины на одном уровне, прежде чем углубляться.

**Пример реализации:**  
```c
#include <stdio.h>
#include <stdbool.h>

#define MAX_VERTICES 5

bool adjacencyMatrix[MAX_VERTICES][MAX_VERTICES] = {
    {0, 1, 0, 0, 1},
    {1, 0, 1, 0, 1},
    {0, 1, 0, 1, 0},
    {0, 0, 1, 0, 1},
    {1, 1, 0, 1, 0}
};

bool visited[MAX_VERTICES] = {0};

void bfs(int start) {
    int queue[MAX_VERTICES];
    int front = 0, rear = 0;

    printf("Visited %d\n", start);
    visited[start] = 1;
    queue[rear++] = start;

    while (front < rear) {
        int vertex = queue[front++];

        for (int i = 0; i < MAX_VERTICES; i++) {
            if (adjacencyMatrix[vertex][i] && !visited[i]) {
                printf("Visited %d\n", i);
                visited[i] = 1;
                queue[rear++] = i;
            }
        }
    }
}
```

---

### **14. Задача поиска кратчайшего пути в графе. Постановки задачи о кратчайшем пути. Алгоритмы поиска кратчайшего пути в графе. Алгоритм Дейкстры. Вычислительная сложность алгоритма Дейкстры**

#### **Постановка задачи:**  
Найти путь между двумя вершинами графа с минимальной суммой весов рёбер.

#### **Алгоритм Дейкстры:**  
Используется для поиска кратчайших путей от одной вершины до всех остальных в графе с положительными весами рёбер.

**Основная идея:**  
- Вводим массив расстояний от начальной вершины до всех остальных (\(dist[]\)).  
- На каждом шаге выбираем вершину с минимальным значением в \(dist[]\) и обновляем расстояния до её соседей.

**Псевдокод:**  
1. Инициализация массива расстояний: начальная вершина = 0, остальные \(\infty\).  
2. Пока есть необработанные вершины:  
   - Выбираем вершину с минимальным расстоянием.
   - Обновляем расстояния до её соседей.  

**Реализация алгоритма Дейкстры на языке Си:**  
```c
#include <stdio.h>
#include <stdbool.h>

#define INF 100000
#define MAX_VERTICES 5

int graph[MAX_VERTICES][MAX_VERTICES] = {
    {0, 10, 0, 0, 5},
    {0, 0, 1, 0, 2},
    {0, 0, 0, 4, 0},
    {7, 0, 6, 0, 0},
    {0, 3, 9, 2, 0}
};

int dist[MAX_VERTICES];
bool visited[MAX_VERTICES];

int getMinVertex() {
    int minDist = INF;
    int minVertex = -1;

    for (int i = 0; i < MAX_VERTICES; i++) {
        if (!visited[i] && dist[i] < minDist) {
            minDist = dist[i];
            minVertex = i;
        }
    }
    return minVertex;
}

void dijkstra(int start) {
    for (int i = 0; i < MAX_VERTICES; i++) {
        dist[i] = INF;
        visited[i] = false;
    }

    dist[start] = 0;

    for (int i = 0; i < MAX_VERTICES - 1; i++) {
        int u = getMinVertex();
        visited[u] = true;

        for (int v = 0; v < MAX_VERTICES; v++) {
            if (graph[u][v] && !visited[v] && dist[u] + graph[u][v] < dist[v]) {
                dist[v] = dist[u] + graph[u][v];
            }
        }
    }

    for (int i = 0; i < MAX_VERTICES; i++) {
        printf("Vertex %d, Distance: %d\n", i, dist[i]);
    }
}
```

**Вычислительная сложность:**  
- При использовании списка смежности и очереди с приоритетом сложность равна \(O((V + E) \log V)\), где \(V\) — количество вершин, \(E\) — количество рёбер.  
- При использовании матрицы смежности сложность составляет \(O(V^2)\).

---

### **15. Остовные деревья минимальной стоимости (MST). Алгоритмы построения MST. Система непересекающихся множеств. Алгоритм Крускала. Алгоритм Прима**

#### **Понятие минимального остовного дерева (MST)**  
Минимальное остовное дерево (MST) — это подмножество рёбер связного графа, которое:  
1. Соединяет все вершины графа.  
2. Не содержит циклов.  
3. Имеет минимальную возможную сумму весов рёбер.

### **Алгоритмы построения MST:**  

#### **Алгоритм Прима (Prim's Algorithm)**  

**Описание:**  
- Стартуем с произвольной вершины и постепенно расширяем дерево, добавляя ребро минимального веса, которое соединяет дерево с новой вершиной.

**Пошаговая процедура:**  
1. Инициализируем массив расстояний до остова (\(key[]\)) значением \(\infty\) для всех вершин, кроме стартовой.  
2. Пока не охвачены все вершины:  
   - Выбираем вершину с минимальным значением в \(key[]\), добавляем её в остов.  
   - Обновляем \(key[]\) для смежных вершин.

**Сложность:** \(O(V^2)\) для матрицы смежности и \(O((V + E) \log V)\) для списка смежности.

**Реализация на языке C:**  
```c
#include <stdio.h>
#include <stdbool.h>

#define INF 100000
#define V 5

int graph[V][V] = {
    {0, 2, 0, 6, 0},
    {2, 0, 3, 8, 5},
    {0, 3, 0, 0, 7},
    {6, 8, 0, 0, 9},
    {0, 5, 7, 9, 0}
};

int minKey(int key[], bool mstSet[]) {
    int min = INF, minIndex;

    for (int v = 0; v < V; v++) {
        if (!mstSet[v] && key[v] < min) {
            min = key[v];
            minIndex = v;
        }
    }
    return minIndex;
}

void primMST() {
    int parent[V];
    int key[V];
    bool mstSet[V];

    for (int i = 0; i < V; i++) {
        key[i] = INF;
        mstSet[i] = false;
    }

    key[0] = 0;
    parent[0] = -1;

    for (int count = 0; count < V - 1; count++) {
        int u = minKey(key, mstSet);
        mstSet[u] = true;

        for (int v = 0; v < V; v++) {
            if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }

    printf("Edge \tWeight\n");
    for (int i = 1; i < V; i++)
        printf("%d - %d \t%d \n", parent[i], i, graph[i][parent[i]]);
}

int main() {
    primMST();
    return 0;
}
```

#### **Алгоритм Крускала (Kruskal's Algorithm)**

**Описание:**  
- Сортирует все рёбра графа по весам и последовательно добавляет их в остовное дерево, избегая циклов.

**Пошаговая процедура:**  
1. Сортируем рёбра по весу.  
2. Добавляем рёбра в остов, если они не образуют цикл (используется система непересекающихся множеств).  

**Сложность:** \(O(E \log E)\) для сортировки и \(O(E \alpha(V))\) для проверки циклов (\(\alpha\) — обратная функция Аккермана).

**Реализация:**  
```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 5

typedef struct {
    int src, dest, weight;
} Edge;

typedef struct {
    int parent[MAX_VERTICES];
    int rank[MAX_VERTICES];
} DisjointSets;

void makeSet(DisjointSets *sets) {
    for (int i = 0; i < MAX_VERTICES; i++) {
        sets->parent[i] = i;
        sets->rank[i] = 0;
    }
}

int find(DisjointSets *sets, int u) {
    if (sets->parent[u] != u) {
        sets->parent[u] = find(sets, sets->parent[u]);
    }
    return sets->parent[u];
}

void unionSets(DisjointSets *sets, int u, int v) {
    int rootU = find(sets, u);
    int rootV = find(sets, v);

    if (rootU != rootV) {
        if (sets->rank[rootU] > sets->rank[rootV]) {
            sets->parent[rootV] = rootU;
        } else if (sets->rank[rootU] < sets->rank[rootV]) {
            sets->parent[rootU] = rootV;
        } else {
            sets->parent[rootV] = rootU;
            sets->rank[rootU]++;
        }
    }
}
```

---

### **16. Основные методы разработки алгоритмов. Метод «грубой силы» (brute force). Метод декомпозиции. Алгоритмы, основанные на методе декомпозиции**

#### **Метод грубой силы (brute force)**  
Прямой перебор всех возможных решений задачи. Этот метод применяется, когда нет оптимального алгоритма или сложность задачи мала.

##### **Примеры:**  
- Поиск подстроки в строке: проверить все возможные подстроки.  
- Перебор перестановок для задачи коммивояжера.

**Сложность:** Обычно экспоненциальная (\(O(n!)\) для задачи перестановок).

#### **Метод декомпозиции (разделяй и властвуй)**  
Разделение задачи на подзадачи, которые решаются независимо и затем объединяются.

##### **Этапы:**  
1. Разделение задачи на подзадачи.  
2. Решение каждой подзадачи.  
3. Объединение решений.

##### **Примеры:**  
- Быстрая сортировка.  
- Сортировка слиянием.  
- Алгоритмы поиска в графах.

**Сложность:** Обычно \(O(n \log n)\) для сортировки.

---

### **17. Методы разработки алгоритмов: динамическое программирование, жадные алгоритмы, поиск с возвратом (backtracking)**  

#### **1) Динамическое программирование (Dynamic Programming)**  
**Идея:** Разделение сложной задачи на пересекающиеся подзадачи и запоминание их решений для избежания повторных вычислений.

**Ключевые принципы:**  
- Определение рекуррентного отношения.  
- Построение таблицы для хранения результатов подзадач.

##### **Пример: Задача о рюкзаке (0-1 Knapsack Problem)**  
**Формулировка:** Дан набор предметов, каждый имеет вес и ценность. Нужно выбрать предметы так, чтобы максимизировать ценность при ограничении по весу.  

**Рекуррентное отношение:**  
\[
K[i][w] = \max(K[i-1][w], K[i-1][w - weight[i]] + value[i])
\]

**Реализация на языке C:**  
```c
#include <stdio.h>
#define MAX_ITEMS 100
#define MAX_WEIGHT 1000

int knapsack(int weight[], int value[], int n, int W) {
    int dp[MAX_ITEMS + 1][MAX_WEIGHT + 1];

    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            if (i == 0 || w == 0) {
                dp[i][w] = 0;
            } else if (weight[i - 1] <= w) {
                dp[i][w] = (value[i - 1] + dp[i - 1][w - weight[i - 1]] > dp[i - 1][w]) ?
                           value[i - 1] + dp[i - 1][w - weight[i - 1]] : dp[i - 1][w];
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }
    return dp[n][W];
}

int main() {
    int weight[] = {1, 2, 3};
    int value[] = {10, 15, 40};
    int W = 5;
    int n = 3;

    printf("Максимальная ценность: %d\n", knapsack(weight, value, n, W));
    return 0;
}
```

#### **2) Жадные алгоритмы (Greedy Algorithms)**  

**Идея:** На каждом шаге алгоритма выбирается локально оптимальное решение, надеясь получить глобально оптимальный результат.

##### **Пример: Кодирование Хаффмана**  
Код Хаффмана минимизирует среднюю длину кода для передачи символов, основываясь на их частоте.

**Алгоритм:**  
1. Построить минимальную кучу из символов и их частот.  
2. Повторно извлекать два минимальных узла и объединять их в новый узел.  
3. Продолжать до тех пор, пока не останется один узел — корень дерева.  

**Сложность:** \(O(n \log n)\)

#### **3) Поиск с возвратом (Backtracking)**  
**Идея:** Последовательный выбор решений и возврат назад при обнаружении противоречий.

##### **Пример: Задача о восьми ферзях**  
Расположить 8 ферзей на шахматной доске так, чтобы они не атаковали друг друга.  

**Реализация на языке C:**  
```c
#include <stdio.h>
#include <stdbool.h>
#define N 8

bool isSafe(int board[N][N], int row, int col) {
    for (int i = 0; i < col; i++) {
        if (board[row][i]) return false;
    }
    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j]) return false;
    }
    for (int i = row, j = col; j >= 0 && i < N; i++, j--) {
        if (board[i][j]) return false;
    }
    return true;
}

bool solveNQueensUtil(int board[N][N], int col) {
    if (col >= N) return true;

    for (int i = 0; i < N; i++) {
        if (isSafe(board, i, col)) {
            board[i][col] = 1;
            if (solveNQueensUtil(board, col + 1)) return true;
            board[i][col] = 0; // backtrack
        }
    }
    return false;
}

void printSolution(int board[N][N]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++)
            printf("%d ", board[i][j]);
        printf("\n");
    }
}

int main() {
    int board[N][N] = {0};
    if (solveNQueensUtil(board, 0)) printSolution(board);
    else printf("Решение не найдено.\n");
    return 0;
}
```

---

### **18. Трудноразрешимые задачи. Классы сложности P и NP. Гамильтонов цикл. Задача коммивояжёра. NP-полнота**  

Задачи NP-класса играют ключевую роль в информатике, и поиск полиномиального решения для них остаётся одной из нерешённых проблем.

#### **Классы сложности:**  

- **P (polynomial):** задачи, которые можно решить за полиномиальное время.  
Пример: поиск кратчайшего пути в графе (алгоритм Дейкстры).  

- **NP (nondeterministic polynomial):** задачи, решение которых можно проверить за полиномиальное время.  
Пример: задача о гамильтоновом цикле (найти цикл, который проходит через все вершины графа ровно один раз).  

#### **NP-полные задачи:**  
Задачи, для которых:  
1. Решение можно проверить за полиномиальное время.  
2. Любая NP-задача сводится к этой задаче за полиномиальное время.

##### **Примеры NP-полных задач:**  
- Задача коммивояжёра (поиск оптимального маршрута).  
- Задача упаковки корзин (Bin Packing).  
- Задача о раскраске графа.

#### **Сводимость задач и NP-полнота:**  
**Сводимость:** превращение одной задачи в другую с помощью полиномиального алгоритма. Если задача сводима к NP-полной задаче и также принадлежит NP, то она NP-полная.

#### **Гамильтонов цикл:**  
Найти путь, который проходит через каждую вершину графа ровно один раз и возвращается в начальную точку.  

#### **Задача коммивояжёра:**  
Найти кратчайший цикл, проходящий через все города ровно один раз.  
- **Экспоненциальная сложность:** \(O(n!)\)
