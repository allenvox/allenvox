# Архитектура ЭВМ

### **1. История вычислительной техники (механические и электромеханические ВМ)**

#### **Механические вычислительные машины:**
- **Абак** (2000 лет до н. э.) — простейшее устройство для выполнения операций сложения и вычитания.
- **Механизм Антикитера** (около 100 года до н. э.) — древнегреческий астрономический механизм, предшественник аналоговых вычислительных устройств.
- **Машина Паскаля (1642)** — первая механическая арифметическая машина для сложения и вычитания, созданная Блезом Паскалем.
- **Арифмометр Лейбница (1673)** — механическая машина, выполняющая операции умножения и деления.
- **Машина Бэббиджа (1837)** — аналитическая машина Чарльза Бэббиджа, предшественник современных программируемых компьютеров. Предполагала наличие арифметического устройства, памяти и управления программами.

#### **Электромеханические вычислительные машины:**
- **Z3 (1941)** — первая полностью программируемая электромеханическая вычислительная машина, разработанная Конрадом Цузе.
- **Mark I (1944)** — первая электромеханическая ЭВМ Гарвардского университета под руководством Говарда Эйкена. Использовала реле и выполняла операции с плавающей точкой.

---

### **2. Поколения ЭВМ**

1. **Первое поколение (1940-е — 1950-е):**  
   - Основа: электронные лампы  
   - Примеры: ENIAC, UNIVAC  
   - Особенности: большие размеры, низкая надежность, высокая энергозатратность, программирование вручную на машинном языке.

2. **Второе поколение (1950-е — 1960-е):**  
   - Основа: транзисторы  
   - Примеры: IBM 7090, БЭСМ-6  
   - Особенности: меньшие размеры, выше надежность, появился ассемблер и языки программирования (Fortran, COBOL).

3. **Третье поколение (1960-е — 1970-е):**  
   - Основа: интегральные схемы  
   - Примеры: IBM System/360  
   - Особенности: многозадачность, операционные системы, высокая скорость обработки данных.

4. **Четвертое поколение (1970-е — 1980-е):**  
   - Основа: большие интегральные схемы (LSI, VLSI)  
   - Примеры: персональные компьютеры (Apple II, IBM PC)  
   - Особенности: массовое использование микропроцессоров.

5. **Пятое поколение (с 1980-х по настоящее время):**  
   - Основа: параллельные архитектуры, нейронные сети, искусственный интеллект  
   - Особенности: мобильные устройства, облачные вычисления, квантовые компьютеры.

---

### **3. Структура ЭВМ Фон Неймана**  

Основные компоненты вычислительной машины по архитектуре фон Неймана:
1. **Устройство управления (Control Unit):** управляет выполнением команд программы.
2. **Арифметико-логическое устройство (ALU):** выполняет арифметические и логические операции.
3. **Память:** хранит данные и программы.
4. **Входные и выходные устройства:** обеспечивают взаимодействие с пользователем.
5. **Шина данных:** передает данные между компонентами.

#### **Принципы фон Неймана:**  
- Программа и данные хранятся в одной памяти.  
- Программный счетчик указывает на текущую выполняемую команду.  
- Последовательное выполнение команд.

---

### **4. Количественные характеристики производительности**

1. **Тактовая частота:** число тактов процессора в секунду (ГГц).  
2. **Количество операций в секунду (FLOPS):** измерение производительности для операций с плавающей точкой.  
3. **Количество инструкций на такт (IPC):** характеризует эффективность выполнения команд.  
4. **Пропускная способность памяти:** объем данных, передаваемых в единицу времени.  
5. **Время доступа к памяти:** время, необходимое для обращения к ячейке памяти.  
6. **Энергопотребление и тепловыделение.**

---

### **5. Типы архитектур вычислительных систем**

1. **SISD (Single Instruction Single Data):**  
   - Последовательное выполнение одной команды над одним потоком данных.  
   - Пример: классический одноядерный процессор.

2. **SIMD (Single Instruction Multiple Data):**  
   - Одна команда выполняется над несколькими потоками данных.  
   - Пример: графические процессоры (GPU).

3. **MISD (Multiple Instruction Single Data):**  
   - Несколько команд выполняются над одним потоком данных (редко используется).

4. **MIMD (Multiple Instruction Multiple Data):**  
   - Несколько команд выполняются над несколькими потоками данных.  
   - Пример: современные многоядерные процессоры.

5. **NUMA (Non-Uniform Memory Access):**  
   - Узлы имеют локальную память, доступ к которой быстрее, чем к удаленной.  

---

### **6. Характеристики памяти ЭВМ**

1. **Емкость:** объем хранимой информации.  
2. **Время доступа:** время, необходимое для чтения или записи данных.  
3. **Пропускная способность:** объем данных, передаваемых за единицу времени.  
4. **Энергопотребление:** потребление энергии на операции с памятью.  
5. **Иерархия памяти:** регистры → кеш → ОЗУ → долговременная память.  

---

### **7. Форматы машинных команд**

Машинная команда состоит из:
- **Кода операции (opcode):** определяет тип операции (сложение, загрузка и т. д.).  
- **Операнды:** адреса регистров или памяти, содержащие данные.  
- **Дополнительные биты:** флаги и служебная информация.

#### **Примеры форматов:**  
1. **Одноадресные команды:** команда и один операнд.  
2. **Двухадресные команды:** команда и два операнда.  
3. **Трехадресные команды:** команда и три операнда.  
4. **Безадресные команды:** данные хранятся в стеке.

---

### **8. Способы адресации памяти**

1. **Прямая адресация:** адрес операнда указан явно.  
   - Пример: `LOAD A`
   
2. **Непрямая адресация:** адрес операнда хранится по указанному адресу.  
   - Пример: `LOAD (A)`

3. **Регистровая адресация:** операнд находится в регистре.  
   - Пример: `ADD R1, R2`

4. **Относительная адресация:** адрес вычисляется относительно текущего значения программного счетчика.  
   - Пример: переходы в программном коде.

5. **Индексная адресация:** адрес операнда вычисляется путем сложения базового адреса и значения индекса.  
   - Пример: `LOAD BASE+INDEX`

6. **Автоинкрементная и автодекрементная адресация:** адрес автоматически увеличивается или уменьшается после обращения.  

---

### **9. RISC и CISC процессоры**

#### **RISC (Reduced Instruction Set Computer)**
- **Особенности:**  
  - Небольшое количество простых и фиксированных команд.
  - Команды выполняются за один такт процессора.
  - Оптимизирована конвейеризация.
- **Примеры:** ARM, MIPS, PowerPC.

#### **CISC (Complex Instruction Set Computer)**
- **Особенности:**  
  - Большое количество сложных команд.
  - Возможность выполнения сложных операций одной командой.
  - Часто используется микроинструкционная реализация.
- **Примеры:** x86 (Intel, AMD).

#### **Сравнение:**
| Характеристика | RISC | CISC |
|:--------------:|:----:|:----:|
| Количество команд | Меньше | Больше |
| Время выполнения | Один такт | Несколько тактов |
| Конвейеризация | Легче реализовать | Сложнее |
| Энергопотребление | Ниже | Выше |
| Программы | Длиннее | Короткие |

---

### **10. Устройство управления с жестким и микропрограммным управлением**

#### **Жесткая логика (hardwired control)**
- Логика управления реализуется на основе схем из логических элементов.
- Быстрая работа, но сложное изменение алгоритмов управления.

#### **Микропрограммное управление (microprogrammed control)**
- Устройство управления использует микропрограммы, хранящиеся в специальной памяти.
- Легко модифицируется, но медленнее по сравнению с жесткой логикой.

#### **Сравнение:**
| Характеристика | Жесткая логика | Микропрограммное управление |
|:-------------:|:-------------:|:---------------------------:|
| Производительность | Высокая | Средняя |
| Гибкость | Низкая | Высокая |
| Время разработки | Длинное | Короче |
| Сложность реализации | Высокая | Ниже |

---

### **11. Методы обмена информацией между МП и внешними устройствами**

1. **Программный опрос (Polling):**
   - Процессор периодически проверяет состояние устройства.
   - Недостаток: высокая загрузка процессора.

2. **Прерывания (Interrupts):**
   - Внешнее устройство инициирует прерывание, после чего процессор обрабатывает запрос.
   - Преимущество: освобождение процессора от постоянных проверок.

3. **Прямой доступ к памяти (DMA):**
   - Контроллер DMA передает данные между памятью и устройством без участия процессора.
   - Высокая производительность.

4. **Обмен по шине (Bus-based communication):**
   - Используется общая шина для передачи данных между компонентами.

---

### **12. Внутренняя структура микропроцессора 8086**

Микропроцессор Intel 8086 состоит из двух основных блоков:

1. **Вычислительное устройство (EU, Execution Unit):**  
   - Выполняет арифметические и логические операции.  
   - Содержит регистры (AX, BX, CX, DX).  

2. **Устройство управления и интерфейса шины (BIU, Bus Interface Unit):**  
   - Отвечает за взаимодействие с внешними устройствами и памятью.  
   - Осуществляет выборку команд, управление шинами адреса и данных.

#### **Основные регистры:**
- **Сегментные регистры:** CS, DS, ES, SS.  
- **Указатели и регистры управления:** IP, BP, SP.  
- **Флаги:** OF, ZF, SF и т. д.

---

### **13. Назначение входов микропроцессора 8086**

1. **Адресные и управляющие входы:**  
   - A19–A16: старшие биты адреса.  
   - BHE (Bus High Enable): выбор старшей части шины данных.

2. **Входы управления памятью:**  
   - RD (Read): сигнал чтения.  
   - WR (Write): сигнал записи.

3. **Входы прерываний:**  
   - INTR (Interrupt Request): запрос прерывания.  
   - NMI (Non-Maskable Interrupt): немаскируемое прерывание.

4. **Входы управления шинами:**  
   - HOLD: запрос передачи управления шиной.  
   - HLDA (Hold Acknowledge): подтверждение передачи управления.

5. **Вход тактового генератора:**  
   - CLK (Clock): синхронизация работы микропроцессора.

---

### **14. Назначение выходов микропроцессора 8086**

1. **Адресные и данные:**  
   - AD0–AD15: мультиплексированная шина адреса и данных.

2. **Управление шинами:**  
   - ALE (Address Latch Enable): сигнал фиксации адреса.  
   - DEN (Data Enable): разрешение передачи данных.

3. **Сигналы состояния:**  
   - M/IO (Memory/Input-Output): выбор режима работы (память или устройство ввода-вывода).  
   - DT/R (Data Transmit/Receive): направление передачи данных.

4. **Выходы управления:**  
   - READY: подтверждение готовности внешних устройств.  
   - RESET: сигнал сброса микропроцессора.

---

### **15. Конвейерные вычисления, общие понятия**

#### **Понятие конвейера**
Конвейерные вычисления подразумевают разделение выполнения задачи на несколько этапов, которые обрабатываются параллельно.

#### **Основные этапы конвейера команд:**
1. **Выборка команды (Fetch)** – загрузка команды из памяти.
2. **Декодирование (Decode)** – определение типа команды и ее операндов.
3. **Выполнение (Execute)** – выполнение вычислительной операции.
4. **Запись результата (Write Back)** – сохранение результата в память или регистр.

#### **Основные преимущества:**
- Повышение производительности за счет параллельного выполнения инструкций.
- Эффективное использование ресурсов процессора.

#### **Основные недостатки:**
- Возможные конфликты между командами.
- Сложность управления.

---

### **16. Конвейер команд**

Конвейер команд — это архитектурная особенность процессоров, позволяющая обрабатывать несколько команд параллельно.

#### **Ключевые стадии конвейера команд:**
1. **IF (Instruction Fetch)** – выборка команды из памяти.
2. **ID (Instruction Decode)** – декодирование команды.
3. **EX (Execute)** – выполнение команды.
4. **MEM (Memory Access)** – доступ к памяти.
5. **WB (Write Back)** – запись результата.

#### **Пример работы:**
- При выполнении одной команды на стадии `EX`, другая может находиться на стадии `IF`, третья — на стадии `MEM` и так далее.

---

### **17. Конфликты в конвейере**

Конфликты (hazards) возникают из-за попытки параллельного выполнения команд.

#### **Типы конфликтов:**

1. **Структурные конфликты (Structural Hazards)**:
   - Возникают при попытке одновременного использования одного и того же ресурса.

2. **Конфликты данных (Data Hazards)**:
   - Возникают, если одна команда зависит от результата другой команды.
   - Виды: 
     - RAW (Read After Write)
     - WAR (Write After Read)
     - WAW (Write After Write)

3. **Конфликты управления (Control Hazards)**:
   - Возникают из-за изменения потока команд (например, из-за условных переходов).

#### **Способы устранения конфликтов:**
- Вставка задержек.
- Предсказание переходов (branch prediction).
- Использование переназначения регистров.

---

### **18. Совмещение и разделение адресных пространств памяти и портов внешних устройств**

1. **Совмещенное адресное пространство:**  
   - Память и внешние устройства используют одну и ту же адресную шину.  
   - Обращение к памяти и устройствам осуществляется через единые команды.  
   - Пример: архитектура x86.

2. **Раздельное адресное пространство:**  
   - Память и устройства ввода-вывода имеют отдельные адресные шины и команды.
   - Более сложное управление, но более высокая производительность.

---

### **19. Иерархическая организация памяти ЭВМ**

Иерархия памяти позволяет сбалансировать скорость доступа и объем памяти.

#### **Основные уровни:**
1. **Регистры:**  
   - Самая быстрая, но ограниченная по объему память.

2. **Кэш-память:**  
   - Быстрая память с малым объемом.
   - Организована в несколько уровней (L1, L2, L3).

3. **Оперативная память (RAM):**  
   - Средняя по скорости и объему.

4. **Внешняя память (HDD, SSD):**  
   - Медленная, но с большим объемом.

5. **Архивная память (оптические диски, ленты):**  
   - Очень медленная, но с огромным объемом.

---

### **20. Шины ЭВМ**

#### **Понятие шины**
Шина — это совокупность линий передачи данных, адресов и управляющих сигналов, которые обеспечивают взаимодействие между компонентами ЭВМ.

#### **Типы шин:**
1. **Шина данных:** передает данные между устройствами.
2. **Шина адреса:** определяет адрес памяти или устройства.
3. **Шина управления:** передает сигналы управления.

#### **Примеры архитектур шин:**
- PCI, PCIe, ISA, USB.

#### **Типы соединений:**
- **Общая шина (shared bus):** одно соединение для всех устройств.
- **Точечное соединение (point-to-point):** прямое соединение между устройствами.

#### **Характеристики шин:**
- Пропускная способность.
- Частота работы.
- Разрядность.

---

### **21. Общие вопросы об ЭВМ и персональном компьютере**

#### **ЭВМ (электронно-вычислительная машина)**
ЭВМ — это устройство, предназначенное для выполнения математических и логических операций. Современные ЭВМ включают процессоры, память и устройства ввода-вывода.

#### **Персональный компьютер (ПК)**
Персональный компьютер — это тип ЭВМ, предназначенный для индивидуального использования. Основные компоненты ПК: материнская плата, процессор, оперативная память, блок питания, устройства ввода-вывода и накопители.

#### **Материнская плата**
Материнская плата связывает все компоненты компьютера и обеспечивает их взаимодействие. На ней размещаются:
- Процессор.
- Оперативная память.
- Чипсет.
- Разъемы для подключения периферийных устройств.

#### **Блок питания**
Блок питания преобразует сетевое напряжение в постоянное и распределяет его между компонентами компьютера. Он обеспечивает стабильную работу системы.

#### **Корпус**
Корпус защищает компоненты компьютера от внешних воздействий и обеспечивает их охлаждение.

#### **Набор микросхем системной логики (чипсет)**
Чипсет управляет взаимодействием между процессором, памятью и периферийными устройствами.

#### **Форм-фактор**
Форм-фактор определяет физические размеры и расположение компонентов на материнской плате (например, ATX, micro-ATX).

#### **Шины персонального компьютера**
- **Шина данных:** передает данные между компонентами.
- **Шина адресов:** определяет адрес устройства или ячейки памяти.
- **Шина управления:** передает управляющие сигналы.

#### **Пропускная способность шины**
Пропускная способность шины рассчитывается как произведение ее ширины (в битах) на частоту работы (в герцах).

#### **Виды памяти**
1. **Статическая память (SRAM):** более быстрая и дорогая, используется для кэш-памяти.
2. **Динамическая память (DRAM):** более медленная и дешевая, используется для оперативной памяти.

#### **Интерфейсы ПК**
Интерфейсы — это способы взаимодействия компонентов. Основные интерфейсы:
- **SATA:** для жестких дисков и SSD.
- **PCI Express:** для видеокарт и других устройств.
- **USB:** для периферийных устройств.
- **HDMI, DisplayPort:** для подключения мониторов.

---

### **22. Таблица истинности и булева функция**

#### **Таблица истинности**
Таблица истинности отображает все возможные комбинации входных значений логической функции и соответствующие выходные значения.

#### **Булева функция**
Булева функция — это функция, которая принимает значения 0 или 1 и возвращает также 0 или 1.

#### **Связь между таблицей истинности и булевой функцией**
Таблица истинности полностью описывает булеву функцию.

#### **Получение булевой функции из таблицы истинности**
- Выбираются строки таблицы истинности, где функция возвращает 1.
- Строится выражение на основе логических операций (конъюнкция и дизъюнкция).

#### **Получение таблицы истинности из булевой функции**
- Перебираются все возможные комбинации значений входных переменных.
- Вычисляется результат функции для каждой комбинации.

#### **Синтез логической схемы**
- По таблице истинности можно построить логическую схему, используя базовые элементы (И, ИЛИ, НЕ).
- По алгебраической формуле схема строится непосредственно на основе операций.

---

### **23. Системы счисления**

#### **Понятие системы счисления**
Система счисления — это способ представления чисел с помощью определенного набора символов.

#### **Позиционные и непозиционные системы счисления**
- **Позиционные:** значение символа зависит от его позиции (двоичная, десятичная, шестнадцатеричная).
- **Непозиционные:** значение символа не зависит от его позиции (римские цифры).

#### **Перевод чисел**
1. **Из двоичной в десятичную:** суммируются значения битов, умноженные на соответствующие степени двойки.
2. **Из двоичной в восьмеричную:** объединяются три бита в одну группу и переводятся в восьмеричные цифры.
3. **Из двоичной в шестнадцатеричную:** объединяются четыре бита в одну группу.
4. **Обратные переводы:** производятся путем деления на основание и записи остатков.

#### **Интерфейсы ПК**
Интерфейсы обеспечивают взаимодействие между компонентами ПК и внешними устройствами (описаны выше).

---

### **24. Флаги и манипуляции с ними**

#### **Понятие флага**
Флаг — это специальный бит, который указывает на состояние процессора или результаты выполнения операции.

#### **Назначение флагов**
Флаги используются для управления выполнением программы и принятия решений.

#### **Манипуляции с флагами**
- **Установка:** выполняется через логические операции (например, `OR`).
- **Сброс:** выполняется через операции `AND` с инверсией.
- **Чтение:** проверка значения флага.

#### **Понятие маски**
Маска — это битовая последовательность, используемая для выборочной обработки битов данных.

#### **Перевод чисел из систем счисления**
(описано выше)

#### **Двоично-десятичное число**
Двоично-десятичное кодирование (BCD) представляет каждую десятичную цифру четырехбитным двоичным числом.

#### **Базовые типы данных в языке Си**
1. **Целые числа:** `int`, `short`, `long`, `long long`
2. **Числа с плавающей точкой:** `float`, `double`
3. **Символы:** `char`
4. **Логические значения:** `bool`
5. **Указатели:** `void *`, `int *`

---

### **25. Взаимодействие с устройствами в Linux**

#### **Специальные файлы устройств**
В Linux устройства представляются специальными файлами, расположенными в каталоге `/dev`. Эти файлы обеспечивают интерфейс для взаимодействия с аппаратным обеспечением.

- **Типы специальных файлов:**
  - **Блочные устройства (block devices):** работают с блоками данных (например, жесткие диски).
  - **Символьные устройства (character devices):** работают с последовательными потоками данных (например, последовательные порты).

#### **Основные функции работы с устройствами**
1. **`open()`** — открывает файл устройства.
   ```c
   int fd = open("/dev/sda", O_RDONLY);
   ```
   Возвращает файловый дескриптор.

2. **`close()`** — закрывает файл устройства.
   ```c
   close(fd);
   ```

3. **`read()`** — считывает данные из устройства.
   ```c
   ssize_t bytesRead = read(fd, buffer, size);
   ```

4. **`write()`** — записывает данные в устройство.
   ```c
   ssize_t bytesWritten = write(fd, buffer, size);
   ```

---

### **26. Терминалы**

#### **Типы терминалов**
1. **Физические терминалы:** аппаратные устройства ввода-вывода.
2. **Виртуальные терминалы:** консоли, доступные через сочетания клавиш (например, `Ctrl + Alt + F1`).
3. **Эмуляторы терминалов:** программы, работающие в графической среде (например, GNOME Terminal).

#### **Режимы работы терминалов**
- **Канонический режим:** ввод обрабатывается построчно.
- **Неканонический режим:** ввод обрабатывается посимвольно.

#### **Управление терминалом**
Для управления параметрами терминала используется библиотека `termios`. Пример изменения параметров терминала:
```c
#include <termios.h>
struct termios old_tio, new_tio;
tcgetattr(STDIN_FILENO, &old_tio);  // Сохранение старых настроек
new_tio = old_tio;
new_tio.c_lflag &= ~ICANON;         // Отключение канонического режима
tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);
```

#### **Основные команды управления терминалом**
- `stty`: управление параметрами терминала.
- `reset`: восстановление параметров терминала.
  
#### **Низкоуровневое управление**
Использование системных вызовов для настройки терминала и обработки ввода-вывода.

---

### **27. Обработка сигналов в Linux**

#### **Сигналы**
Сигналы — это механизм асинхронного взаимодействия между процессами и ядром. Они используются для уведомления процесса о событиях (например, `SIGINT`, `SIGTERM`, `SIGKILL`).

#### **Обработка сигналов**
1. **Игнорирование сигнала:** процесс не реагирует на сигнал.
2. **Обработка сигнала:** вызов пользовательской функции-обработчика.
3. **Действие по умолчанию:** стандартное поведение ОС.

#### **Функция для обработки сигналов**
```c
#include <signal.h>
#include <stdio.h>

void signal_handler(int signum) {
    printf("Получен сигнал %d\n", signum);
}

int main() {
    signal(SIGINT, signal_handler);  // Установка обработчика
    while (1);
    return 0;
}
```

---

### **28. Прерывания и сигналы**

Прерывания генерируются аппаратными устройствами или программами для немедленной обработки событий.
Сигналы генерируются операционной системой и передаются процессам для уведомления об определенных событиях.

#### **Основные отличия**
| **Прерывание**         | **Сигнал**            |
|------------------------|-----------------------|
| Генерируется аппаратурой | Генерируется ОС         |
| Обрабатывается драйвером| Обрабатывается процессом |
| Привязано к железу     | Привязано к процессу    |

#### **Информация, передаваемая прерыванием и сигналом**
- **Прерывание:** тип устройства, адрес операции.
- **Сигнал:** номер сигнала и контекст вызова.

---

### **29. Настройка и обработка таймера в Linux**

#### **Настройка таймера**
Для работы с таймерами в Linux используется системный вызов `setitimer`.

#### **Пример установки таймера**
```c
#include <stdio.h>
#include <signal.h>
#include <sys/time.h>

void timer_handler(int signum) {
    printf("Таймер сработал!\n");
}

int main() {
    struct itimerval timer;
    signal(SIGALRM, timer_handler);

    // Настройка таймера
    timer.it_value.tv_sec = 1;         // Первое срабатывание через 1 секунду
    timer.it_value.tv_usec = 0;
    timer.it_interval.tv_sec = 1;      // Интервал повторения 1 секунда
    timer.it_interval.tv_usec = 0;

    setitimer(ITIMER_REAL, &timer, NULL);

    while (1);
    return 0;
}
```

#### **Как программа узнает о срабатывании таймера**
Программа получает сигнал `SIGALRM`, который можно обработать через функцию-обработчик.

---

### **30. Как пользовательская программа может узнать об изменении размера окна виртуального терминала**

#### **Использование сигнала `SIGWINCH`**
Когда пользователь изменяет размер окна терминала, операционная система отправляет процессу сигнал `SIGWINCH` (Window Change).

#### **Пример обработки сигнала `SIGWINCH`**
```c
#include <signal.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <unistd.h>

void handle_winch(int sig) {
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    printf("Новый размер окна: %d строк, %d столбцов\n", w.ws_row, w.ws_col);
}

int main() {
    signal(SIGWINCH, handle_winch);  // Установка обработчика сигнала
    while (1) {
        pause();  // Ожидание сигналов
    }
    return 0;
}
```
#### **Объяснение**
- Системный вызов `ioctl` с параметром `TIOCGWINSZ` позволяет получить текущие размеры окна терминала.
- Структура `struct winsize` содержит поля:
  - `ws_row`: количество строк.
  - `ws_col`: количество столбцов.

---

### **31. Основные этапы загрузки ПК на базе процессоров семейства Intel**

1. **Аппаратный сброс и POST (Power-On Self-Test)**
   - Инициализация аппаратных устройств.
   - Проверка оперативной памяти, видеокарты, клавиатуры.

2. **Выполнение кода BIOS/UEFI**
   - Загрузка настроек из CMOS.
   - Определение загрузочных устройств.

3. **Загрузка загрузчика (Bootloader)**
   - BIOS/UEFI передает управление первому сектору загрузочного устройства.
   - Пример загрузчиков: GRUB, LILO.

4. **Этап загрузки ядра ОС**
   - Загрузка ядра операционной системы в память.
   - Передача управления ядру.

5. **Инициализация ядра**
   - Настройка драйверов устройств.
   - Монтирование корневой файловой системы.

6. **Запуск системных служб и инициализация пользовательского окружения**
   - Запуск служб, настроенных в системе инициализации (Systemd, SysV).
   - Запуск оболочки (shell) или графического интерфейса.

---

### **32. Геометрия жесткого диска**

#### **Геометрия жесткого диска**
Геометрия жесткого диска определяет его физическую или логическую структуру. Основные параметры:
- **C (Cylinders)** — количество цилиндров.
- **H (Heads)** — количество головок чтения-записи.
- **S (Sectors per track)** — количество секторов на дорожку.

#### **Пример записи геометрии**
Допустим, жесткий диск имеет параметры `C=1024, H=16, S=63`, это значит, что он содержит:
\[
1024 \times 16 \times 63 = 1032192 \text{ секторов}
\]

#### **Трансляция геометрии**
Трансляция используется для обеспечения совместимости между различными устройствами и BIOS. Она преобразует физические параметры жесткого диска в логические.

#### **Типы трансляции**
1. **CHS (Cylinder-Head-Sector)** — классический способ доступа к данным.
2. **LBA (Logical Block Addressing)** — адресация блоков логически, а не по геометрическим параметрам.
3. **Enhanced CHS (ECHS)** — улучшенная трансляция CHS для поддержки больших объемов.

#### **Преимущества LBA**
- Упрощенная адресация данных.
- Поддержка больших объемов жестких дисков.
- Повышение производительности.

---

### **33. LBA адресация. Зачем используется. Перевод из LBA в CHS и наоборот**

#### **LBA (Logical Block Addressing)**
LBA — это способ линейной адресации секторов жесткого диска, который заменяет устаревшую адресацию CHS (Cylinder-Head-Sector).

#### **Зачем используется LBA**
- Упрощение работы с дисками больших объемов.
- Устранение ограничений CHS (255 головок, 1024 цилиндров, 63 сектора).
- Поддержка современных файловых систем и загрузчиков.

#### **Формула перевода из LBA в CHS**
C = LBA / (H*S)
H = (LBA/S) mod H
S = (LBA mod S) + 1

#### **Перевод из CHS в LBA**
LBA = (C * H * S) + H*S + S - 1

Где:
- `C` — номер цилиндра
- `H` — номер головки
- `S` — номер сектора (начиная с 1)

---

### **34. Адресация секторов жесткого диска. Типы адресации. Барьеры размеров дисков**

#### **Типы адресации**
1. **CHS (Cylinder-Head-Sector)** — адресация по цилиндрам, головкам и секторам.
   - Ограничение: до 8 ГБ на диск из-за ограничений BIOS.
2. **LBA (Logical Block Addressing)** — линейная адресация секторов.
   - Теоретически поддерживает объем до 2 ТБ для 32-битных регистров.

#### **Барьеры размеров дисков**
1. **Барьеры BIOS 8.4 ГБ и 137 ГБ (28-битный LBA)**  
   Ограничение из-за невозможности адресовать сектора больше `2^28` блоков.
   
2. **Барьеры файловых систем (4K секторы и GPT)**
   - Введение формата GPT и отказ от MBR позволили преодолеть 2 ТБ ограничение.

---

### **35. Логическая организация винчестера. Разделы диска. Таблица разделов**

#### **Логическая организация винчестера**
- Разделение физического диска на логические части (разделы) для хранения данных и операционных систем.
- Основные виды разделов:
  - **Основные разделы (Primary Partition)** — до 4 разделов.
  - **Расширенный раздел (Extended Partition)** — содержит логические разделы.

#### **Таблица разделов**
Таблица разделов описывает расположение разделов и хранится в MBR (Master Boot Record) или GPT (GUID Partition Table).

#### **Зачем используется таблица разделов**
- Организация хранения данных.
- Возможность установки нескольких ОС.
- Указание файловых систем для каждого раздела.

#### **Структура MBR**
- Первые 446 байт — загрузчик (bootloader).
- Следующие 64 байта — таблица разделов (4 записи по 16 байт).
- Последние 2 байта — сигнатура (`0x55AA`).

---

### **36. Адресация секторов жесткого диска. Типы адресации. Барьеры размеров дисков**

(Этот вопрос дублирует 34-й)

#### **Барьеры и их причины**
1. **BIOS 528 МБ (1024 цилиндра)** — из-за ограничений CHS.
2. **8.4 ГБ барьер** — из-за ограничений количества головок и секторов.
3. **137 ГБ барьер (28-битное LBA)** — физический предел адресации для 32-битных систем.
4. **2 ТБ барьер для MBR** — из-за ограниченной длины полей в таблице разделов MBR.
5. **64 ЗБ барьер для GPT (128-битное LBA)** — фактически устранено.

#### **Решение барьеров**
- Переход от CHS к LBA.
- Введение файловой системы GPT вместо MBR.
- Использование 64-битной адресации.
